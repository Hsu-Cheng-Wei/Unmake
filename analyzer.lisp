(ql:quickload "xmls")                   ;TODO: document quicklisp as a dependency

(defpackage :unmake
  (:use :common-lisp))
(in-package :unmake)

(defun to-sexpr (cbf-file)
  "Parse a file in the Common Build Format and return an sexpr representing
  the dependency tree contained therein."
  (with-open-file (cbf-str cbf-file :direction :input)
    (let ((cbf-sexpr (xmls:parse cbf-str)))
      (cddr cbf-sexpr) ;discards <build> stuff, which isn't useful to us
      )))

(defun munge-rule (rule)
  "Takes the sexpr structure of a rule as generated by XMLS and munges it into
  a much more useful format, such that we can build a reasonable alist or hash
  for the whole shebang."
  (labels
    ((rule-name (rule)
       (intern (car (cdaadr rule))))
     (dep-name (dep)
       (intern (caddr dep)))
     (rule-deps (rule)
       (mapcar #'dep-name (cddr rule))))

    (cons (rule-name rule) (list (rule-deps rule)))))

(defun to-alist (cbf-sexpr)
  (mapcar #'munge-rule cbf-sexpr))

(defun to-hash (cbf-sexpr)
  (let ((spine (make-hash-table)))
    (mapc (lambda (rule)
              (setf (gethash (car (munge-rule rule)) spine)
                    (cdr (munge-rule rule)))) cbf-sexpr)
    spine ))

(defun count-rules (cbf-sexpr)
  "Returns the number of rules defined in the dependency tree represented by
  cbf-sexpr"
  (if (eq cbf-sexpr nil) 0
    (+ 1 (count-rules (cdr cbf-sexpr)))))

(defun depth-first-traverse (alist)
  "Performs a DFT of the given alist, returning a cons of (cyclicp . build-order)
  where cyclicp represents whether the dependency graph represented by alist
  contains any cycles, and build-order is a list representing what you'd expect."
  (let ((head (caar alist)))
    (flet ((dft (alist node)
             "recursive helper function"
             ;TODO: implement (build-order should just be reverse of pre-order)
             (cons nil (cons alist node)) ;placeholder
             ))
      (dft alist head))))

(defun analyze (cbf-file)
  "Analyze and report on the properties of a Common Build Format file"
  (if (eq cbf-file nil) (setf cbf-file "cbf.xml"))

  (format t "Report for the build system described in ~a: ~&" cbf-file)
  (format t "    Number of rules: ~d ~&" (count-rules (to-sexpr cbf-file)))
  (format t "    Build graph ~a cyclic ~&"
          (if (car (depth-first-traverse (to-alist (to-sexpr cbf-file))))
            "is"
            "is not")))
